# Push swap

2개의 Stack과 11개의 명령어를 이용하여 정렬을 구현하는 최적방법을 찾는 문제

## 룰

### 목표
Game에 2개의 `stack`(`a`, `b`)이 존재하고 시작할 때, `a`에 정렬되지 않은 `stack`이 존재하며 아래 명령어를 적절히 실행하여 최종적으로 `a`가 정렬된 `stack`이 되도록 하는것이 목표이다.

### 명령어
- `sa` : `a` 의 최상단 2개 요소의 위치를 변경한다.
- `sb` : `b` 의 최상단 2개 요소의 위치를 변경한다.
- `ss` : `sa`와 `sb`를 동시에 실행한다.

- `pa` : `b`의 최상단 요소를 `a`의 최상단으로 넘긴다.
- `pb` : `a`의 최상단 요소를 `b`의 최상단으로 넘긴다.

- `ra` : `a`의 최상단 요소를 최하단으로 보낸다.
- `rb` : `b`의 최상단 요소를 최하단으로 보낸다.
- `rr` : `ra`와 `rb`를 동시에 실행한다.

- `rra` : `a`의 최하단 요소를 최상단으로 보낸다.
- `rrb` : `b`의 최하단 요소를 최상단으로 보낸다.
- `rrr` : `rra`와 `rrb`를 동시에 실행한다.

## 프로그램 구성
### "checker" 프로그램
**checker**는 `a stack`에 넣을 값을 argument로 받고 실행할 명령을 stdin으로 받아 실행 후 해당 요소가 게임의 목표(정렬된 `a stack`)에 부합하는 지 확인한다.

### "push_swap" 프로그램
**push_swap**은 argument로 `a stack`의 요소를 받고 게임의 최적해를 찾는 프로그램

## 프로그램 구축
### Basic
프로그램은 기본적으로 2개의 `stack`을 가져야 하고 11개의 명령어를 실행해야한다. 따라서 해당 프로그램을 관리할 매니저를 구현한다.
`c`에는 `stack`이 구현되어 있지않기에 배열을 2개 만들어 두고 각각의 길이를 저장하는 구조체를 구현해둔다.
```c

```

위 구조에대해 11개의 명령어를 각각 구현해둔다.

[]()
